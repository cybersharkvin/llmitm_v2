"""Exploit tool implementations for ActionGraph execution.

Each exploit tool converts an AttackOpportunity into a sequence of CAMRO Steps.
These are called deterministically during the AttackPlan -> ActionGraph conversion.
The agent never calls these directly — it prescribes them in the attack plan output.
"""

from typing import List

from llmitm_v2.constants import StepPhase, StepType
from llmitm_v2.models.step import Step
from llmitm_v2.target_profiles import TargetProfile


def _login_and_auth_steps(profile: TargetProfile, user: str = "a") -> List[Step]:
    """Login + optional token extraction. Returns 1-2 steps depending on auth mechanism.

    bearer_token: 2 steps (POST login + regex extract token)
    session_cookie: 1 step (POST login, cookies auto-tracked by HTTPRequestHandler)
    session_cookie + csrf: 2 steps (GET login page to extract CSRF token, POST login with CSRF)
    """
    creds = profile.user_a if user == "a" else profile.user_b
    field_user, field_pass = profile.login_body_fields
    body = {field_user: creds.username, field_pass: creds.password}
    suffix = f" (User {'A' if user == 'a' else 'B'})" if user != "a" else ""

    if profile.auth_mechanism == "session_cookie" and profile.csrf_token_pattern:
        return [
            Step(
                order=0, phase=StepPhase.CAPTURE, type=StepType.HTTP_REQUEST,
                command=f"GET {profile.login_path} (csrf)",
                parameters={"method": "GET", "path": profile.login_path},
                success_criteria="user_token|csrf",
            ),
            Step(
                order=0, phase=StepPhase.ANALYZE, type=StepType.REGEX_MATCH,
                command="extract CSRF token",
                parameters={"pattern": profile.csrf_token_pattern, "source": "{{previous_outputs[-1]}}", "capture_group": 1},
                success_criteria=".",
            ),
            Step(
                order=0, phase=StepPhase.CAPTURE, type=StepType.HTTP_REQUEST,
                command=f"POST {profile.login_path}{suffix}",
                parameters={"method": "POST", "path": profile.login_path, "body": {**body, "user_token": "{{previous_outputs[-1]}}"}},
                success_criteria=".",
            ),
        ]

    steps: List[Step] = [
        Step(
            order=0, phase=StepPhase.CAPTURE, type=StepType.HTTP_REQUEST,
            command=f"POST {profile.login_path}{suffix}",
            parameters={"method": "POST", "path": profile.login_path, "body": body},
            success_criteria="authentication" if profile.auth_mechanism == "bearer_token" else ".",
        ),
    ]

    if profile.auth_mechanism == "bearer_token" and profile.token_extraction_pattern:
        steps.append(Step(
            order=0, phase=StepPhase.ANALYZE, type=StepType.REGEX_MATCH,
            command=f"extract token{suffix}",
            parameters={"pattern": profile.token_extraction_pattern, "source": "{{previous_outputs[-1]}}", "capture_group": 1},
            success_criteria=".",
        ))

    return steps


def _auth_headers(profile: TargetProfile, token_ref: str) -> dict[str, str]:
    """Return Authorization header dict for bearer, empty dict for cookie auth."""
    if profile.auth_mechanism == "bearer_token":
        return {"Authorization": f"Bearer {token_ref}"}
    return {}


def _auth_offset(profile: TargetProfile) -> int:
    """Number of steps _login_and_auth_steps produces for user 'a'."""
    if profile.auth_mechanism == "session_cookie" and profile.csrf_token_pattern:
        return 3
    if profile.auth_mechanism == "bearer_token" and profile.token_extraction_pattern:
        return 2
    return 1


def idor_walk_steps(exploit_target: str, observation: str, profile: TargetProfile) -> List[Step]:
    """Generate CAMRO steps for IDOR testing."""
    steps = _login_and_auth_steps(profile, "a")
    headers = _auth_headers(profile, "{{previous_outputs[-1]}}")
    offset = _auth_offset(profile)
    steps.extend([
        Step(
            order=0, phase=StepPhase.CAPTURE, type=StepType.HTTP_REQUEST,
            command=f"GET {exploit_target}",
            parameters={"method": "GET", "path": exploit_target, **( {"headers": headers} if headers else {})},
            success_criteria=r'"id"',
        ),
        Step(
            order=0, phase=StepPhase.MUTATE, type=StepType.HTTP_REQUEST,
            command=f"GET {_increment_id(exploit_target)}",
            parameters={
                "method": "GET", "path": _increment_id(exploit_target),
                **({"headers": _auth_headers(profile, f"{{{{previous_outputs[-{offset + 1}]}}}}")} if headers else {}),
            },
            success_criteria=r'"id"',
        ),
        Step(
            order=0, phase=StepPhase.OBSERVE, type=StepType.REGEX_MATCH,
            command="check IDOR",
            parameters={"pattern": r'"id"', "source": "{{previous_outputs[-1]}}"},
            success_criteria=r'"id"',
        ),
    ])
    return steps


def auth_strip_steps(exploit_target: str, observation: str, profile: TargetProfile) -> List[Step]:
    """Generate CAMRO steps for auth stripping."""
    steps = _login_and_auth_steps(profile, "a")
    headers = _auth_headers(profile, "{{previous_outputs[-1]}}")
    no_auth_params: dict = {"method": "GET", "path": exploit_target}
    if profile.auth_mechanism == "session_cookie":
        no_auth_params["skip_cookies"] = True

    steps.extend([
        Step(
            order=0, phase=StepPhase.CAPTURE, type=StepType.HTTP_REQUEST,
            command=f"GET {exploit_target} (auth'd)",
            parameters={"method": "GET", "path": exploit_target, **({"headers": headers} if headers else {})},
            success_criteria=".",
        ),
        Step(
            order=0, phase=StepPhase.REPLAY, type=StepType.HTTP_REQUEST,
            command=f"GET {exploit_target} (no auth)",
            parameters=no_auth_params,
            success_criteria=".",
        ),
        Step(
            order=0, phase=StepPhase.OBSERVE, type=StepType.REGEX_MATCH,
            command="check auth strip",
            parameters={"pattern": r'"id"|"email"|"data"', "source": "{{previous_outputs[-1]}}"},
            success_criteria=r'"id"|"email"|"data"',
        ),
    ])
    return steps


def token_swap_steps(exploit_target: str, observation: str, profile: TargetProfile) -> List[Step]:
    """Generate CAMRO steps for token swapping. Bearer-only — raises ValueError for cookie auth."""
    if profile.auth_mechanism == "session_cookie":
        raise ValueError("token_swap requires bearer_token auth (cannot hold 2 sessions in 1 cookie jar)")

    steps = _login_and_auth_steps(profile, "a")
    steps.extend(_login_and_auth_steps(profile, "b"))
    steps.extend([
        Step(
            order=0, phase=StepPhase.REPLAY, type=StepType.HTTP_REQUEST,
            command=f"GET {exploit_target} with User B's token",
            parameters={
                "method": "GET", "path": exploit_target,
                "headers": {"Authorization": "Bearer {{previous_outputs[-1]}}"},
            },
            success_criteria=r'"id"',
        ),
        Step(
            order=0, phase=StepPhase.OBSERVE, type=StepType.REGEX_MATCH,
            command="check token swap",
            parameters={"pattern": r'"id"', "source": "{{previous_outputs[-1]}}"},
            success_criteria=r'"id"',
        ),
    ])
    return steps


def namespace_probe_steps(exploit_target: str, observation: str, profile: TargetProfile) -> List[Step]:
    """Generate CAMRO steps for namespace probing."""
    base_path = "/".join(exploit_target.rstrip("/").split("/")[:-1])
    siblings = ["config", "admin", "settings", "users", "debug", "internal"]
    steps: List[Step] = [
        Step(
            order=0, phase=StepPhase.CAPTURE, type=StepType.HTTP_REQUEST,
            command=f"GET {exploit_target} (baseline)",
            parameters={"method": "GET", "path": exploit_target},
            success_criteria=".",
        ),
    ]
    for sib in siblings:
        steps.append(Step(
            order=0, phase=StepPhase.REPLAY, type=StepType.HTTP_REQUEST,
            command=f"GET {base_path}/{sib}",
            parameters={"method": "GET", "path": f"{base_path}/{sib}"},
        ))
    steps.append(Step(
        order=0, phase=StepPhase.OBSERVE, type=StepType.REGEX_MATCH,
        command="check namespace probes",
        parameters={"pattern": r'"id"|"email"|"data"|"config"|"admin"', "source": "{{previous_outputs[-1]}}"},
        success_criteria=r'"id"|"email"|"data"|"config"|"admin"',
    ))
    return steps


def role_tamper_steps(exploit_target: str, observation: str, profile: TargetProfile) -> List[Step]:
    """Generate CAMRO steps for role tampering."""
    steps = _login_and_auth_steps(profile, "a")
    headers = _auth_headers(profile, "{{previous_outputs[-1]}}")
    steps.extend([
        Step(
            order=0, phase=StepPhase.MUTATE, type=StepType.HTTP_REQUEST,
            command=f"POST {exploit_target} with role=admin",
            parameters={
                "method": "POST", "path": exploit_target,
                **({"headers": headers} if headers else {}),
                "body": {"role": "admin"},
            },
            success_criteria=".",
        ),
        Step(
            order=0, phase=StepPhase.OBSERVE, type=StepType.REGEX_MATCH,
            command="check role tamper",
            parameters={"pattern": r'"role"\s*:\s*"admin"', "source": "{{previous_outputs[-1]}}"},
            success_criteria=r'"role"\s*:\s*"admin"',
        ),
    ])
    return steps


def _increment_id(path: str) -> str:
    """Increment the last numeric segment in a URL path for IDOR testing."""
    import re
    match = re.search(r'/(\d+)(?=[/?#]|$)', path)
    if match:
        old_id = match.group(1)
        new_id = str(int(old_id) + 1)
        return path[:match.start(1)] + new_id + path[match.end(1):]
    return path + "/2"


# Registry mapping exploit tool name -> step generator
EXPLOIT_STEP_GENERATORS = {
    "idor_walk": idor_walk_steps,
    "auth_strip": auth_strip_steps,
    "token_swap": token_swap_steps,
    "namespace_probe": namespace_probe_steps,
    "role_tamper": role_tamper_steps,
}
